<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/client/client.es6.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/collective-soundworks/soundworks" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/client/client.es6.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;

const MobileDetect = require(&apos;mobile-detect&apos;);
const ClientModule = require(&apos;./ClientModule&apos;);
// import ClientModule from &apos;./ClientModule.es6.js&apos;;

// debug - http://socket.io/docs/logging-and-debugging/#available-debugging-scopes
// localStorage.debug = &apos;*&apos;;

/**
 * The `client` object contains the basic methods of the client. For instance, the object initializes the client type with `init` and establishes WebSocket communications with the server through the methods `send` and `receive`. Additionally, it starts the scenario and sequences the modules using the methods `start`, `serial` and `parallel`.
 * @type {Object}
 */
var client = {
  type: null,
  ready: null,
  index: -1,
  coordinates: null,
  init: init,
  start: start,
  // deprecated functions
  serial: serial,
  parallel: parallel,

  io: null,
  socket: null,
  send: send,
  receive: receive,
  removeListener: removeListener,
  platform: {
    os: null,
    isMobile: null,
    audioFileExt: &apos;&apos;,
    isForbidden: false
  }
};

// get informations about client
const ua = window.navigator.userAgent
const md = new MobileDetect(ua);
client.platform.isMobile = (md.mobile() !== null); // true if phone or tablet
client.platform.os = (() =&gt; {
  let os = md.os();

  if (os === &apos;AndroidOS&apos;) {
    return &apos;android&apos;;
  } else if (os === &apos;iOS&apos;) {
    return &apos;ios&apos;;
  } else {
    return &apos;other&apos;;
  }
})();

// audio file extention check
const a = document.createElement(&apos;audio&apos;);
// http://diveintohtml5.info/everything.html
if (!!(a.canPlayType &amp;&amp; a.canPlayType(&apos;audio/mpeg;&apos;))) {
  client.platform.audioFileExt = &apos;.mp3&apos;;
} else if (!!(a.canPlayType &amp;&amp; a.canPlayType(&apos;audio/ogg; codecs=&quot;vorbis&quot;&apos;))) {
  client.platform.audioFileExt = &apos;.ogg&apos;;
} else {
  client.platform.audioFileExt = &apos;.wav&apos;;
}

/**
 * The `init` method sets the client type and initializes a WebSocket connection associated with the given type.
 * @param {String} [clientType = &apos;player&apos;] The client type.
 * @todo clarify clientType.
 * @param {Object} [options = {}] The options to initialize a client
 * @param {Boolean} [options.io] By default, a Soundworks application has a client and a server side. For a standalone application (client side only), use `options.io = false`.
 * @todo use default value for options.io in the documentation?
 * @param {String} [options.socketUrl] The URL of the WebSocket server.
 */
function init(clientType = &apos;player&apos;, options = {}) {
  client.type = clientType;
  client.io = null;

  if (options.io === undefined) { options.io = true; }
  if (options.socketUrl === undefined) { options.socketUrl = &apos;&apos;; }

  if (options.io !== false) {
    var io = require(&apos;socket.io-client&apos;);

    client.io = io;
    client.socket = client.io(options.socketUrl + &apos;/&apos; + clientType, {
      transports: [&apos;websocket&apos;]
    });

    client.ready = new Promise((resolve) =&gt; {
      client.receive(&apos;client:start&apos;, (index) =&gt; {
        client.index = index;
        resolve();
      });
    });
  }
}

/**
 * Starts the module logic (*i.e.* the application).
 * @param {Function} startFun [todo]
 * @todo Clarify the param.
 * @return {Promise} The Promise return value.
 * @todo Clarify return value (promise).
 * @todo example
 */
function start(startFun) {
  let module = startFun; // be compatible with previous version

  if (typeof startFun === &apos;function&apos;)
    module = startFun(ClientModule.sequential, ClientModule.parallel);

  let promise = module.createPromise();

  if (client.io) {
    client.ready
      .then(() =&gt; module.launch());

    client.receive(&apos;disconnect&apos;, () =&gt; {
      // console.log(&apos;disconnect&apos;, client.index);
    });

    client.receive(&apos;reconnect&apos;, () =&gt; {
      // console.log(&apos;reconnect&apos;, client.index);
    });
  } else {
    // no client i/o, no server
    module.launch();
  }

  return promise;
}

/**
 * The `serial` method returns a `ClientModule` that starts the given `...modules` in series. After starting the first module (by calling its `start` method), the next module in the series is started (with its `start` method) when the last module called its `done` method. When the last module calls `done`, the returned serial module calls its own `done` method.
 *
 * **Note:** you can compound serial module sequences with parallel module combinations (*e.g.* `client.serial(module1, client.parallel(module2, module3), module4);`).
 * @deprecated Use the new API with the {@link start} method.
 * @param {...ClientModule} ...modules The modules to run in serial.
 * @return {Promise} [description]
 * @todo Clarify return value
 */
function serial(...modules) {
  console.log(&apos;The function &quot;client.serial&quot; is deprecated. Please use the new API instead.&apos;);
  return ClientModule.sequential(...modules);
}

/**
 * The `ClientModule` returned by the `parallel` method starts the given `...modules` in parallel (with their `start` methods), and calls its `done` method after all modules called their own `done` methods.
 *
 * **Note:** you can compound parallel module combinations with serial module sequences (*e.g.* `client.parallel(module1, client.serial(module2, module3), module4);`).
 *
 * **Note:** the `view` of a module is always full screen, so in the case where modules run in parallel, their `view`s are stacked on top of each other using the `z-index` CSS property.
 * We use the order of the `parallel` method&apos;s arguments to determine the order of the stack (*e.g.* in `client.parallel(module1, module2, module3)`, the `view` of `module1` is displayed on top of the `view` of `module2`, which is displayed on top of the `view` of `module3`).
 * @deprecated Use the new API with the {@link start} method.
 * @param {...ClientModule} modules The modules to run in parallel.
 * @return {Promise} [description]
 * @todo Clarify return value
 */
function parallel(...modules) {
  console.log(&apos;The function &quot;client.parallel&quot; is deprecated. Please use the new API instead.&apos;);
  return ClientModule.parallel(...modules);
}

/**
 * Sends a WebSocket message to the server.
 *
 * **Note:** on the server side, the server receives the message with the command {@link ServerClient#receive}.
 * @param {String} msg Name of the message to send.
 * @param {...*} args Arguments of the message (as many as needed, of any type).
 */
function send(msg, ...args) {
  if (client.socket)
    client.socket.emit(msg, ...args);
}

/**
 * Executes a callback function when it receives a WebSocket message from the server.
 *
 * **Note:** on the server side, the server sends the message with the command {@link server.send}`.
 * @param {String} msg Name of the received message.
 * @param {Function} callback Callback function executed when the message is received.
 */
function receive(msg, callback) {
  if (client.socket) {
    client.socket.removeListener(msg, callback);
    client.socket.on(msg, callback);
  }
}

/**
 * [removeListener description]
 * @private
 * @param {[type]} msg [description]
 * @param {Function} callback [description]
 * @todo doc
 */
function removeListener(msg, callback) {
  if (client.socket)
    client.socket.removeListener(msg, callback);
}

// export default client;
module.exports = client;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
