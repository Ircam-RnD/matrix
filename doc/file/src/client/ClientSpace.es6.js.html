<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/client/ClientSpace.es6.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/collective-soundworks/soundworks" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/client/ClientSpace.es6.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const ns = &apos;http://www.w3.org/2000/svg&apos;;

const client = require(&apos;./client&apos;);
const ClientModule = require(&apos;./ClientModule&apos;);
// import client from &apos;./client.es6.js&apos;;
// import ClientModule from &apos;./ClientModule.es6.js&apos;;

/**
 * The {@link ClientSpace} displays the setup upon request.
 */
class ClientSpace extends ClientModule {
// export default class ClientSpace extends ClientModule {
  /**
   * Creates an instance of the class.
   * @param {Object} [options={}] Options.
   * @param {String} [options.name=&apos;space&apos;] Name of the module.
   * @param {Boolean} [options.fitContainer=false] Indicates whether the graphical representation fits the container size or not.
   * @param {Boolean} [options.listenTouchEvent=false] Indicates whether to setup a listener on the space graphical representation or not.
   */
  constructor(options = {}) {
    super(options.name ||&#xA0;&apos;space&apos;);

    /**
     * Relative width of the setup.
     * @type {Number}
     */
    this.width = 1;

    /**
     * Relative heigth of the setup.
     * @type {Number}
     */
    this.height = 1;

    this._fitContainer = (options.fitContainer ||&#xA0;false);
    this._listenTouchEvent = (options.listenTouchEvent || false);

    // this.spacing = 1;
    // this.labels = [];
    // this.coordinates = [];
    this.type = undefined;

    this._xFactor = 1;
    this._yFactor = 1;

    // map between shapes and their related positions
    this.shapePositionMap = [];
    this.positionIndexShapeMap = {};
  }

  // TODO note -&gt; modfiy here
  initSetup(setup) {
    this.width = setup.width;
    this.height = setup.height;
    // this.spacing = setup.spacing;
    // this.labels = setup.labels;
    // this.coordinates = setup.coordinates;
    this.type = setup.type;
    this.background = setup.background;

    this.done();
  }

  /**
   * Starts the module.
   * @private
   */
  start() {
    super.start();
    this.done();
    // client.receive(&apos;setup:init&apos;, this._onSetupInit);
    // client.send(&apos;setup:request&apos;);
  }

  /**
   * Restarts the module.
   * @private
   */
  restart() {
    super.restart();
    this.done();
  }

  /**
   * Resets the module.
   * @private
   */
  reset() {
    this.shapePositionMap = [];
    this.positionIndexShapeMap = {};
    // client.removeListener(&apos;setup:init&apos;, this._onSetupInit);
    this.container.innerHTML = &apos;&apos;;
  }

  /**
   * The `display` method displays a graphical representation of the setup.
   * @param {ClientSetup} setup Setup to display.
   * @param {DOMElement} container Container to append the setup representation to.
   * @param {Object} [options={}] Options.
   * @param {String} [options.transform] Indicates which transformation to aply to the representation. Possible values are:
   * - `&apos;rotate180&apos;`: rotates the representation by 180 degrees.
   */
  display(setup, container, options = {}) {
    this.initSetup(setup);
    this.container = container;
    this.container.classList.add(&apos;space&apos;);
    this.renderingOptions = options;

    if (options.showBackground) {
      this.container.style.backgroundImage = `url(${this.background})`;
      this.container.style.backgroundPosition = &apos;50% 50%&apos;;
      this.container.style.backgroundRepeat = &apos;no-repeat&apos;;
      this.container.style.backgroundSize = &apos;contain&apos;;
    }

    const svg = document.createElementNS(ns, &apos;svg&apos;);
    const group = document.createElementNS(ns, &apos;g&apos;);

    svg.appendChild(group);
    this.container.appendChild(svg);

    this.svg = svg;
    this.group = group;

    this._resize(this.container);
  }

  _resize() {
    const boundingRect = this.container.getBoundingClientRect();
    const containerWidth = boundingRect.width;
    const containerHeight = boundingRect.height;
    // force adaptation to container size

    const ratio = (() =&gt; {
      return (this.width &gt; this.height) ?
        containerWidth / this.width :
        containerHeight / this.height;
    })();

    let svgWidth = this.width * ratio;
    let svgHeight = this.height * ratio;

    if (this._fitContainer) {
      svgWidth = containerWidth;
      svgHeight = containerHeight;
    }

    const offsetLeft = (containerWidth - svgWidth) / 2;
    const offsetTop = (containerHeight - svgHeight) / 2;

    this.svg.setAttributeNS(null, &apos;width&apos;, svgWidth);
    this.svg.setAttributeNS(null, &apos;height&apos;, svgHeight);
     // use setup coordinates
    this.svg.setAttributeNS(null, &apos;viewBox&apos;, `0 0 ${this.width} ${this.height}`);
    // center svg in container
    this.svg.style.position = &apos;absolute&apos;;
    this.svg.style.left = `${offsetLeft}px`;
    this.svg.style.top = `${offsetTop}px`;

    // apply rotations
    if (this.renderingOptions.transform) {
      switch (this.renderingOptions.transform) {
        case &apos;rotate180&apos;:
          this.container.setAttribute(&apos;data-xfactor&apos;, -1);
          this.container.setAttribute(&apos;data-yfactor&apos;, -1);
          const transform = `rotate(180, ${svgWidth / 2}, ${svgHeight / 2})`;
          this.group.setAttributeNS(null, &apos;transform&apos;, transform);
          break;
      }
    }

    this.svgOffsetLeft = offsetLeft;
    this.svgOffsetTop = offsetTop;
    this.svgWidth = svgWidth;
    this.svgHeight = svgHeight;

    this.ratio = ratio;
  }

  /**
   * Display an array of positions.
   * @param {Object[]} positions Positions to display.
   * @param {Number} size Size of the positions to display.
   */
  displayPositions(positions, size) {
    // clean surface
    this.removeAllPositions();

    positions.forEach((position) =&gt; {
      this.addPosition(position, size);
    });

    // add listeners
    if (this._listenTouchEvent) {
      this.container.addEventListener(&apos;touchstart&apos;, (e) =&gt; {
        e.preventDefault();
        const dots = this.shapePositionMap.map((entry) =&gt; { return entry.dot });
        let target = e.target;

        // Could probably be simplified...
        while (target !== this.container) {
          if (dots.indexOf(target) !== -1) {
            for (let i = 0; i &lt; this.shapePositionMap; i++) {
              const entry = this.shapePositionMap[i];
              if (target === entry.dot) {
                const position = entry.position;
                this.emit(&apos;select&apos;, position);
              }
            }
          }

          target = target.parentNode;
        }
      });
    }
  }

  /**
   * Adds a position to the display.
   * @param {Object} position Position to add.
   * @param {Number} size Size of the position to draw.
   */
  addPosition(position, size) {
    const radius = size / 2;
    const coordinates = position.coordinates;
    const index = position.index;

    const dot = document.createElementNS(ns, &apos;circle&apos;);
    dot.setAttributeNS(null, &apos;r&apos;, radius / this.ratio);
    dot.setAttributeNS(null, &apos;cx&apos;, coordinates[0] * this.width);
    dot.setAttributeNS(null, &apos;cy&apos;, coordinates[1] * this.height);
    dot.style.fill = &apos;steelblue&apos;;

    this.group.appendChild(dot);
    this.shapePositionMap.push({ dot, position });
    this.positionIndexShapeMap[index] = dot;
  }

  /**
   * Removes a position from the display.
   * @param {Object} position Position to remove.
   */
  removePosition(position) {
    const el = this. positionIndexShapeMap[position.index];
    this.group.removeChild(el);
  }

  /**
   * Remove all the positions displayed.
   */
  removeAllPositions() {
    while (this.group.firstChild) {
      this.group.removeChild(this.group.firstChild);
    }
  }
}

module.exports = ClientSpace;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
