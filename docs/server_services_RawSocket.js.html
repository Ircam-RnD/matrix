<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Soundworks - Source: server/services/RawSocket.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/overrides.css">
</head>

<body>

<div id="main">

    <!-- if home page assume a title is already present in README -->
    
    <h1 class="page-title">Source: server/services/RawSocket.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import server from '../core/server';
import Service from '../core/Service';
import serviceManager from '../core/serviceManager';
import { Server as WebSocketServer } from 'ws';
import http from 'http';
import https from 'https';
import pem from 'pem';
import fs from 'fs';

const SERVICE_ID = 'service:raw-socket';


/**
 * Protocol defined in configuration is added to these two entry that manage
 * the handshake at the creation of the socket.
 * @private
 */
const baseProtocol = [
  { channel: 'service:handshake', type: 'Uint32' },
  { channel: 'service:handshake-ack', type: 'Uint8' },
];

/**
 * Counter that create tokens in order to match sockets and clients.
 * @private
 */
let counter = 0;

/**
 * Interface for the `raw-socket` service.
 *
 * This service creates an additionnal native socket with its binary type set
 * to `arraybuffer` and focused on performances.
 * It allows the transfert of `TypedArray` data wrapped with a minimal channel
 * mechanism (up to 256 channels).
 *
 * The user-defined protocol must follow the convention:
 * @example
 * const protocol = [
 *   { channel: 'my-channel', type: 'Float32' }
 *   // ...
 * ]
 *
 * Where the `channel` can be any string and the `type` can be interpolated
 * to any `TypedArray` by concatenating `'Array'` at its end.
 *
 * __*The service must be used with its [client-side counterpart]{@link module:soundworks/client.RawSocket}*__
 *
 * @memberof module:soundworks/server
 */
class RawSocket extends Service {
  constructor() {
    super(SERVICE_ID);

    const defaults = {
      configItem: 'rawSocket',
    };

    this.configure(defaults);

    this._port = null;
    this._protocol = null;
    this._channels = null;

    /**
     * Listeners for the incomming messages.
     *
     * @type {Map&lt;client, Set&lt;Function>>}
     * @name _listeners
     * @memberof module:soundworks/server.RawSocket
     * @instance
     * @private
     */
    this._listeners = new Map();

    this._tokenClientMap = new Map();
    this._clientSocketMap = new Map();
    this._socketClientMap = new Map();

    this._protocol = baseProtocol;

    // retrieve service config + useHttps
    this._sharedConfig = this.require('shared-config');

    this._onConnection = this._onConnection.bind(this);
  }

  configure(options) {
    if (options.protocol)
      this._protocol = this._protocol.concat(options.protocol);

    super.configure(options);
  }

  addProtocolDefinition(def) {
    this._protocol.push(def);
  }

  /** @private */
  start() {
    super.start();

    const configItem = this.options.configItem;
    const config = this._sharedConfig.get(configItem);

    this._port = config.port;

    if (Array.isArray(config.protocol))
      this._protocol = this.protocol.concat(config.protocol);

    this._channels = this._protocol.map((def) => def.channel);

    // check http / https mode
    let useHttps = server.config.useHttps;

    // launch http(s) server
    if (!useHttps) {
      let httpServer = http.createServer();
      this.runServer(httpServer);
    } else {
      const httpsServer = https.createServer(server.httpsInfos);
      this.runServer(httpsServer);
    }
  }

  runServer(server){
    server.listen(this._port, () => {
      // console.log(SERVICE_ID, ': Https server listening on port:', this._port);
    });

    this._wss = new WebSocketServer({ server: server });
    this._wss.on('connection', this._onConnection);
    this.ready();
  }

  /** @private */
  connect(client) {
    // send infos to create the socket to the client
    super.receive(client, 'request', () => {
      const token = counter += 1;
      this._tokenClientMap.set(token, client);

      super.send(client, 'infos', this._port, this._protocol, token);
    });
  }

  disconect(client) {
    const socket = this._clientSocketMap.get(client);

    this._clientSocketMap.delete(client);
    this._socketClientMap.delete(socket);
  }

  /** @private */
  _onConnection(socket) {
    socket.on('message', (buffer) => {
      buffer = new Uint8Array(buffer).buffer;
      const index = new Uint8Array(buffer)[0];

      if (!this._protocol[index])
        throw new Error('Invalid protocol index: ${index}');

      const { channel, type } = this._protocol[index];
      const viewCtor = global[`${type}Array`];
      const data = new viewCtor(buffer, viewCtor.BYTES_PER_ELEMENT);

      if (channel === 'service:handshake')
        this._pairClientSocket(socket, data[0]);
      else
        this._propagateEvent(socket, channel, data);
    });
  }

  /**
   * Associate the socket with the corresponding client according to the `token`
   *
   * @param {Socket} socket - Socket which receive the message.
   * @param {Number} token - Token to match the client associated to the socket.
   * @private
   */
  _pairClientSocket(socket, token) {
    const client = this._tokenClientMap.get(token);
    this._clientSocketMap.set(client, socket);
    this._socketClientMap.set(socket, client);
    this._tokenClientMap.delete(token);

    this.send(client, 'service:handshake-ack');
  }

  /**
   * Call all the registered listener associated to a client.
   *
   * @param {Socket} socket - Socket which received the message.
   * @param {String} channel - Channel of the message.
   * @param {TypedArray} data - Received data.
   * @private
   */
  _propagateEvent(socket, channel, data) {
    const client = this._socketClientMap.get(socket);
    const clientListeners = this._listeners.get(client);
    const callbacks = clientListeners[channel];

    callbacks.forEach((callback) => callback(data));
  }

  /**
   * Register a callback function on a specific channel.
   *
   * @param {client} client - Client to listen the message from.
   * @param {String} channel - Channel of the message.
   * @param {Function} callback - Callback function.
   */
  receive(client, channel, callback) {
    const listeners = this._listeners;

    if (!listeners.has(client))
      listeners.set(client, {});

    const clientListeners = listeners.get(client);

    if (!clientListeners[channel])
      clientListeners[channel] = new Set();

    clientListeners[channel].add(callback);
  }

  /**
   * Send data to a specific client, on a given channel.
   *
   * @param {client} client - Client to send the message to.
   * @param {String} channel - Channel of the message.
   * @param {TypedArray} data - Data.
   */
  send(client, channel, data) {
    const socket = this._clientSocketMap.get(client);
    const index = this._channels.indexOf(channel);

    if (index === -1)
      throw new Error(`Undefined channel "${channel}"`);

    const { type } = this._protocol[index];
    const viewCtor = global[`${type}Array`];
    const size = data ? 1 + data.length : 1;
    const view = new viewCtor(size);

    const channelView = new Uint8Array(viewCtor.BYTES_PER_ELEMENT);
    channelView[0] = index;
    // populate final buffer
    view.set(new viewCtor(channelView.buffer), 0);

    if (data)
      view.set(data, 1);

    socket.send(view.buffer);
  }

  /**
   * Broadcast data to several client at once.
   *
   * @param {String|Array} clientType - Type or types of client to send the
   *  message to.
   * @param {client} excludeClient - Client to exclude from the broadcast.
   * @param {String} channel - Channel of the message.
   * @param {TypedArray} data - Data.
   */
  broadcast(clientType, excludeClient, channel, data) {
    if (!Array.isArray(clientType))
      clientType = [clientType];

    for (let client of this._clientSocketMap.keys()) {
      if (clientType.indexOf(client.type) !== -1 &amp;&amp; client !== excludeClient)
        this.send(client, channel, data);
    }
  }
}

serviceManager.register(SERVICE_ID, RawSocket);

export default RawSocket;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-soundworks_client.html">soundworks/client</a></li><li><a href="module-soundworks_server.html">soundworks/server</a></li></ul><h3>Classes</h3><ul><li><a href="module-soundworks_client.Activity.html">soundworks/client.Activity</a></li><li><a href="module-soundworks_client.AudioBufferManager.html">soundworks/client.AudioBufferManager</a></li><li><a href="module-soundworks_client.AudioScheduler.html">soundworks/client.AudioScheduler</a></li><li><a href="module-soundworks_client.AudioStreamManager.html">soundworks/client.AudioStreamManager</a></li><li><a href="module-soundworks_client.AudioStreamManager.AudioStream.html">soundworks/client.AudioStreamManager.AudioStream</a></li><li><a href="module-soundworks_client.Auth.html">soundworks/client.Auth</a></li><li><a href="module-soundworks_client.Canvas2dRenderer.html">soundworks/client.Canvas2dRenderer</a></li><li><a href="module-soundworks_client.Canvas2dRenderingGroup.html">soundworks/client.Canvas2dRenderingGroup</a></li><li><a href="module-soundworks_client.CanvasView.html">soundworks/client.CanvasView</a></li><li><a href="module-soundworks_client.Checkin.html">soundworks/client.Checkin</a></li><li><a href="module-soundworks_client.ErrorReporter.html">soundworks/client.ErrorReporter</a></li><li><a href="module-soundworks_client.Experience.html">soundworks/client.Experience</a></li><li><a href="module-soundworks_client.FileSystem.html">soundworks/client.FileSystem</a></li><li><a href="module-soundworks_client.Geolocation.html">soundworks/client.Geolocation</a></li><li><a href="module-soundworks_client.Locator.html">soundworks/client.Locator</a></li><li><a href="module-soundworks_client.MotionInput.html">soundworks/client.MotionInput</a></li><li><a href="module-soundworks_client.Network.html">soundworks/client.Network</a></li><li><a href="module-soundworks_client.Placer.html">soundworks/client.Placer</a></li><li><a href="module-soundworks_client.Platform.html">soundworks/client.Platform</a></li><li><a href="module-soundworks_client.RawSocket.html">soundworks/client.RawSocket</a></li><li><a href="module-soundworks_client.SegmentedView.html">soundworks/client.SegmentedView</a></li><li><a href="module-soundworks_client.Service.html">soundworks/client.Service</a></li><li><a href="module-soundworks_client.SharedConfig.html">soundworks/client.SharedConfig</a></li><li><a href="module-soundworks_client.SharedParams.html">soundworks/client.SharedParams</a></li><li><a href="module-soundworks_client.Sync.html">soundworks/client.Sync</a></li><li><a href="module-soundworks_client.SyncScheduler.html">soundworks/client.SyncScheduler</a></li><li><a href="module-soundworks_client.View.html">soundworks/client.View</a></li><li><a href="module-soundworks_server.Activity.html">soundworks/server.Activity</a></li><li><a href="module-soundworks_server.AudioBufferManager.html">soundworks/server.AudioBufferManager</a></li><li><a href="module-soundworks_server.AudioStreamManager.html">soundworks/server.AudioStreamManager</a></li><li><a href="module-soundworks_server.Auth.html">soundworks/server.Auth</a></li><li><a href="module-soundworks_server.Checkin.html">soundworks/server.Checkin</a></li><li><a href="module-soundworks_server.ErrorReporter.html">soundworks/server.ErrorReporter</a></li><li><a href="module-soundworks_server.Experience.html">soundworks/server.Experience</a></li><li><a href="module-soundworks_server.Geolocation.html">soundworks/server.Geolocation</a></li><li><a href="module-soundworks_server.Locator.html">soundworks/server.Locator</a></li><li><a href="module-soundworks_server.MetricScheduler.html">soundworks/server.MetricScheduler</a></li><li><a href="module-soundworks_server.Network.html">soundworks/server.Network</a></li><li><a href="module-soundworks_server.Osc.html">soundworks/server.Osc</a></li><li><a href="module-soundworks_server.Placer.html">soundworks/server.Placer</a></li><li><a href="module-soundworks_server.RawSocket.html">soundworks/server.RawSocket</a></li><li><a href="module-soundworks_server.Service.html">soundworks/server.Service</a></li><li><a href="module-soundworks_server.SharedConfig.html">soundworks/server.SharedConfig</a></li><li><a href="module-soundworks_server.SharedParams.html">soundworks/server.SharedParams</a></li><li><a href="module-soundworks_server.Sync.html">soundworks/server.Sync</a></li><li><a href="module-soundworks_server.SyncScheduler.html">soundworks/server.SyncScheduler</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-soundworks_client.client.html">soundworks/client.client</a></li><li><a href="module-soundworks_client.viewport.html">soundworks/client.viewport</a></li><li><a href="module-soundworks_server.server.html">soundworks/server.server</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-soundworks_client.AbstractAudioBufferManagerView.html">soundworks/client.AbstractAudioBufferManagerView</a></li><li><a href="module-soundworks_client.AbstractAuthView.html">soundworks/client.AbstractAuthView</a></li><li><a href="module-soundworks_client.AbstractCheckinView.html">soundworks/client.AbstractCheckinView</a></li><li><a href="module-soundworks_client.AbstractLocatorView.html">soundworks/client.AbstractLocatorView</a></li><li><a href="module-soundworks_client.AbstractPlacerView.html">soundworks/client.AbstractPlacerView</a></li><li><a href="module-soundworks_client.AbstractPlatformView.html">soundworks/client.AbstractPlatformView</a></li><li><a href="module-soundworks_client.AbstractView.html">soundworks/client.AbstractView</a></li></ul>
</nav>

<br class="clear">

<footer>
    
        Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Tue Nov 12 2019 14:44:16 GMT+0100 (Central European Standard Time)
    
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
