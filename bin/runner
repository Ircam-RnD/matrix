#!/usr/bin/env node
const fse = require('fs-extra');
const watch = require('watch');
const path = require('path');
const fileStore = require('./fileStore');
const log = require('./log');
const transpiler = require('./transpiler');
const { escapeRegExp, getTime, isJs } = require('./utils');
const pkg = require('../package.json');
const cwd = process.cwd();

// --------------------------------------------------------------------------
// Tools configuration
// --------------------------------------------------------------------------

const babelOptions = JSON.parse(fse.readFileSync(path.join(cwd, '.babelrc')));

const watchOptions = {
  ignoreDotFiles: true,
  ignoreUnreadableDir: true,
  ignoreNotPermitted: true,
  interval: 0.25, // watch internally use `fs.watchFile`
};

function getWatchOptions() {
  return Object.assign({}, watchOptions);
}

const srcDirectory = path.join(cwd, 'src');
const srcRegExp = new RegExp('^' + escapeRegExp(srcDirectory));

const distDirectory = path.join(cwd, '.');

// -------------------------------------------------------------
// Reusable logic
// -------------------------------------------------------------

async function transpileOrCopy(filename) {
  const src = await fileStore.get(filename);
  const distFilename = src.abs.replace(srcRegExp, distDirectory);
  const dist = await fileStore.get(distFilename);
  const startTime = getTime();

  if (!isJs(src)) {
    try {
      fse.copySync(src.abs, dist.abs);
      log.copyFileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.copyFileError(src, err);
      return Promise.reject([src, dist]);
    }
  } else {
    try {
      await transpiler.transpile(src, dist, babelOptions);
      log.transpileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.transpileError(src, err);
      return Promise.reject();
    }
  }
}

async function transpileOrCopyAll() {
  const files = await fileStore.getAll(srcDirectory);
  const pairs = [];

  for (let i = 0; i < files.length; i++) {
    try {
      const src = files[i];
      const pair = await transpileOrCopy(src);
      pairs.push(pair);
    } catch(err) {
      return Promise.reject(err);
    }
  }

  return pairs;
}

async function deleteFile(file) {
  try {
    fileStore.delete(file);
    log.deleteFileSuccess(file);
    return Promise.resolve(file);
  } catch(err) {
    log.deleteFileError(file, err)
    return Promise.reject(file);
  }
}

function watchSrc() {
  function updateFile(filename) {
    transpileOrCopy(filename).catch(err => {});
  }

  watch.createMonitor(srcDirectory, Object.assign({}, watchOptions), monitor => {
    monitor.on('created', updateFile);
    monitor.on('changed', updateFile);
    // delete dist file
    monitor.on('removed', async (filename, stats) => {
      const distFilename = filename.replace(srcRegExp, distDirectory);
      const dist = await fileStore.get(distFilename).then();
      await deleteFile(dist);
    });
  });
}


// -------------------------------------------------------------
// Handle commands
// -------------------------------------------------------------

async function __transpile() {
  try {
    const transpiledJS = await transpileOrCopyAll();
    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

async function __watch() {
  try {
    watchSrc();

    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

async function __clear() {
  const directories = [
    await fileStore.get(path.join('client')),
    await fileStore.get(path.join('server')),
    await fileStore.get(path.join('thing')),
    await fileStore.get(path.join('utils')),
  ];

  directories.forEach(async function(dir) {
    try {
      await deleteFile(dir);
      return Promise.resolve();
    } catch(err) {
      return Promise.reject();
    }
  });
}


// -------------------------------------------------------------
// Parse commands
// -------------------------------------------------------------

const command = process.argv[2];

switch (command) {
  case '--clear':
    __clear().catch(err => {});
    break;
  case '--watch':
    __transpile().then(__watch).catch(err => {});
    break;
  case '--transpile':
    __transpile().catch(err => {});
    break;
  case '--help':
    console.log(`
[${pkg.name}] available commands:

- \`npm run clear\`\tclean the project, delete \`client/\`, \`server\`, \`thing\` and \`utils\`
- \`npm run transpile\`\ttranspile all sources
- \`npm run watch\`\ttranspile a given file on change

    `);
    break;
}


