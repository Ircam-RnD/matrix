#!/usr/bin/env node
const fse = require('fs-extra');
const watch = require('watch');
const path = require('path');
const fileStore = require('./fileStore');
const log = require('./log');
const transpiler = require('./transpiler');
const utils = require('./utils');

// var javascripts = require('./javascripts');
const cwd = process.cwd();

// --------------------------------------------------------------------------
// Tools configuration
// --------------------------------------------------------------------------

const babelOptions = JSON.parse(fse.readFileSync(path.join(cwd, '.babelrc')));

const watchOptions = {
  ignoreDotFiles: true,
  ignoreUnreadableDir: true,
  ignoreNotPermitted: true,
  interval: 2, // watch internally use `fs.watchFile`
};

function getWatchOptions() {
  return Object.assign({}, watchOptions);
}

const srcDirectory = path.join(cwd, 'src');
const srcRegExp = new RegExp('^' + escapeRegExp(srcDirectory));

const distDirectory = path.join(cwd, '.');

// /**
//  * Define which file should be ignored by every command.
//  */
// var allowedExtentions = /\.js$/;
// var excludeFiles = /^\./; // exclude hidden files

/* --------------------------------------------------------------------------
 * -------------------------------------------------------------------------- */

/**
 * Test the given filename, to ensure it can be processed by any command / tranpsiler
 * @param {String} filename - The filename to be checked.
 * @param {Boolean} [ensureFile=true] - If set to false, don't test if the file exists.
 */
// function isAllowed(filename, ensureFile) {
//   ensureFile = ensureFile === undefined ? true : ensureFile;

//   var basename = path.basename(filename);
//   var isFile = true;

//   if (ensureFile) {
//     try {
//       isFile = fse.lstatSync(filename).isFile() && !fse.lstatSync(filename).isSymbolicLink();
//     } catch(e) {
//       console.log(e.message);
//       isFile = false;
//     }
//   }

//   var hasAllowedExt = allowedExtentions.test(basename);
//   var notExcludeFile = !excludeFiles.test(basename);

//   return isFile && hasAllowedExt && notExcludeFile;
// }

/**
 * transpile files (babel)
 */
async function transpileOrCopy(filename) {
  const src = await fileStore.get(filename);
  const distFilename = src.abs.replace(srcRegExp, distDirectory);
  const dist = await fileStore.get(distFilename);
  const startTime = getTime();

  if (!isJs(src)) {
    try {
      fse.copySync(src.abs, dist.abs);
      log.copyFileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.copyFileError(src, err);
      return Promise.reject([src, dist]);
    }
  } else {
    try {
      await transpiler.transpile(src, dist, babelOptions);
      log.transpileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.transpileError(src, err);
      return Promise.reject([src, dist]);
    }
  }
}

async function transpileOrCopyAll() {
  const files = await fileStore.getAll(srcDirectory);
  const pairs = [];

  for (let i = 0; i < files.length; i++) {
    try {
      const src = files[i];
      const pair = await transpileOrCopy(src);
      pairs.push(pair);
    } catch(err) {
      return Promise.reject(err);
    }
  }

  return pairs;
}

async function deleteFile(file) {
  try {
    fileStore.delete(file);
    log.deleteFileSuccess(file);
    return Promise.resolve(file);
  } catch(err) {
    log.deleteFileError(file, err)
    return Promise.reject(file);
  }
}

/**
 * Watch javascript source files.
 */
function watchSrc() {
  watch.createMonitor(srcDirectory, Object.assign({}, watchOptions), monitor => {
    monitor.on('created', transpileOrCopy);
    monitor.on('changed', transpileOrCopy);
    // delete dist file
    monitor.on('removed', async (filename, stats) => {
      const distFilename = filename.replace(srcRegExp, distDirectory);
      const dist = await fileStore.get(distFilename).then();
      await deleteFile(dist);
    });
  });
}

async function __transpile() {
  try {
    const transpiledJS = await transpileOrCopyAll();
    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

async function __watch() {
  try {
    watchSrc();

    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

async function __clear() {
  const directories = [
    await fileStore.get(path.join('client')),
    await fileStore.get(path.join('server')),
    await fileStore.get(path.join('thing')),
    await fileStore.get(path.join('utils')),
  ];

  directories.forEach(async function(dir) {
    try {
      await deleteFile(dir);
      return Promise.resolve();
    } catch(err) {
      return Promise.reject();
    }
  });
}


// -------------------------------------------------------------
// Parse commands
// -------------------------------------------------------------

const command = process.argv[2];

switch (command) {
  case '--clear':
    __clear().catch(err => console.error(err.stack));
    break;
  case '--watch':
    __transpile().then(__watch).catch(err => console.error(err.stack));
    break;
  case '--transpile':
    __transpile().catch(err => console.error(err.stack));
    break;
  case '--help':
    console.log(`
[${pkg.name}] available commands:

- \`npm run clear\`\tclean the project, delete \`client/\`, \`server\`, \`thing\` and \`utils\`
- \`npm run transpile\`\ttranspile and bundle all sources (js and css)
- \`npm run watch\`\trun the server, and transpile, bundle, and restart server on file change

    `);
    break;
}


